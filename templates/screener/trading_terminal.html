{% extends "base.html" %}
{% load static %}
{% load formatting %}
{% load i18n %}
{% get_current_language as LANGUAGE_CODE %}

{% block title %}{% trans "Trading Terminal" %} ‚Äî {{ symbol.symbol }}{% endblock %}


{% block content %}
<div class="trading-terminal-container">
    <div class="trading-header">
        <div class="trading-symbol-info">
            <div class="symbol-selector-container">
                <input type="text" 
                       id="symbol-search-input" 
                       class="symbol-search-input" 
                       placeholder="{% trans 'Search symbol...' %}" 
                       value="{{ symbol.symbol }}"
                       autocomplete="off">
                <div id="symbol-dropdown" class="symbol-dropdown"></div>
            </div>
            <span class="market-type-badge {% if market_type == 'futures' %}futures{% else %}spot{% endif %}" id="market-type-badge">
                {{ market_type|upper }}
            </span>
            <button class="btn-secondary btn-small" id="toggle-market-type" title="{% trans 'Toggle market type' %}">
                üîÑ
            </button>
            {% if latest_snapshot %}
                <div class="price-info">
                    <span class="current-price" id="current-price">{{ latest_snapshot.price|format_price }}</span>
                    <span class="price-change {% if latest_snapshot.change_15m > 0 %}positive{% elif latest_snapshot.change_15m < 0 %}negative{% endif %}" id="price-change">
                        {{ latest_snapshot.change_15m|floatformat:2 }}%
                    </span>
                </div>
            {% endif %}
        </div>
        <div class="trading-header-actions">
            <a href="{% url 'alerts:create' symbol.symbol %}?market_type={{ market_type }}" class="btn-primary">
                üîî {% trans "Create Alert" %}
            </a>
        </div>
        {% if latest_snapshot %}
            <div class="trading-stats-inline" id="trading-stats-container">
                <!-- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±—É–¥–µ—Ç –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∞ —á–µ—Ä–µ–∑ JavaScript -->
            </div>
            <button class="btn-secondary btn-small" id="configure-stats-btn" title="{% trans 'Configure indicators' %}">
                ‚öôÔ∏è
            </button>
        {% endif %}
    </div>

    <div class="trading-chart-container">
        <div id="tradingview-widget-container" class="tradingview-widget-container">
            <div id="tradingview-widget" class="tradingview-widget"></div>
        </div>
    </div>
</div>

{% if snapshot_data %}
{{ snapshot_data|json_script:"initial-snapshot-data" }}
{% endif %}

<script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    let currentSymbol = '{{ symbol.symbol }}';
    let marketType = '{{ market_type }}';
    let tradingViewWidget = null;
    let symbolSearchTimeout = null;
    let symbolsCache = {};
    
    // –ó–∞–≥—Ä—É–∑–∫–∞ —Å–ø–∏—Å–∫–∞ —Å–∏–º–≤–æ–ª–æ–≤
    function loadSymbols(search = '', callback) {
        const cacheKey = `${marketType}_${search}`;
        if (symbolsCache[cacheKey]) {
            callback(symbolsCache[cacheKey]);
            return;
        }
        
        // Preserve language prefix
        const langPrefix = window.getLanguagePrefix ? window.getLanguagePrefix() : (window.location.pathname.match(/^\/(ru|en|es|he)\//)?.[1] || 'ru');
        // Build API path based on current URL structure (same logic as screener.js)
        const currentPath = window.location.pathname;
        const pathParts = currentPath.split('/').filter(p => p);
        const hasLangPrefix = pathParts.length > 0 && ['ru', 'en', 'es', 'he'].includes(pathParts[0]);
        
        const apiPath = hasLangPrefix 
            ? `/${pathParts[0]}/api/symbols/`
            : `/api/symbols/`;
        
        fetch(`${apiPath}?market_type=${marketType}&search=${encodeURIComponent(search)}`)
            .then(res => res.json())
            .then(data => {
                symbolsCache[cacheKey] = data.symbols;
                callback(data.symbols);
            })
            .catch(err => {
                console.error('Failed to load symbols:', err);
                callback([]);
            });
    }
    
    // –ü–æ–∏—Å–∫ —Å–∏–º–≤–æ–ª–æ–≤
    const symbolSearchInput = document.getElementById('symbol-search-input');
    const symbolDropdown = document.getElementById('symbol-dropdown');
    
    function showSymbolDropdown(symbols) {
        symbolDropdown.innerHTML = '';
        if (symbols.length === 0) {
            symbolDropdown.style.display = 'none';
            return;
        }
        
        symbolDropdown.style.display = 'block';
        symbols.slice(0, 10).forEach(s => {
            const item = document.createElement('div');
            item.className = 'symbol-dropdown-item';
            item.textContent = s.symbol;
            item.onclick = () => {
                selectSymbol(s.symbol);
            };
            symbolDropdown.appendChild(item);
        });
    }
    
    function selectSymbol(symbol) {
        currentSymbol = symbol;
        symbolSearchInput.value = symbol;
        symbolDropdown.style.display = 'none';
        
        // Preserve language prefix
        const langPrefix = window.getLanguagePrefix ? window.getLanguagePrefix() : (window.location.pathname.match(/^\/(ru|en|es|he)\//)?.[1] || 'ru');
        const langPath = langPrefix && langPrefix !== 'ru' ? `/${langPrefix}` : '';
        
        // –û–±–Ω–æ–≤–ª—è–µ–º URL –∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É
        const newUrl = `${langPath}/trading/${symbol}/?market_type=${marketType}`;
        window.location.href = newUrl;
    }
    
    symbolSearchInput.addEventListener('input', function() {
        const search = this.value.trim();
        clearTimeout(symbolSearchTimeout);
        
        if (search.length < 1) {
            symbolDropdown.style.display = 'none';
            return;
        }
        
        symbolSearchTimeout = setTimeout(() => {
            loadSymbols(search, showSymbolDropdown);
        }, 300);
    });
    
    symbolSearchInput.addEventListener('focus', function() {
        const search = this.value.trim();
        if (search.length >= 1) {
            loadSymbols(search, showSymbolDropdown);
        }
    });
    
    // –ó–∞–∫—Ä—ã—Ç–∏–µ –≤—ã–ø–∞–¥–∞—é—â–µ–≥–æ —Å–ø–∏—Å–∫–∞ –ø—Ä–∏ –∫–ª–∏–∫–µ –≤–Ω–µ –µ–≥–æ
    document.addEventListener('click', function(e) {
        if (!symbolSearchInput.contains(e.target) && !symbolDropdown.contains(e.target)) {
            symbolDropdown.style.display = 'none';
        }
    });
    
    // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ç–∏–ø–∞ —Ä—ã–Ω–∫–∞
    const toggleMarketTypeBtn = document.getElementById('toggle-market-type');
    if (toggleMarketTypeBtn) {
        toggleMarketTypeBtn.addEventListener('click', function() {
            marketType = marketType === 'spot' ? 'futures' : 'spot';
            
            // Preserve language prefix
            const langPrefix = window.getLanguagePrefix ? window.getLanguagePrefix() : (window.location.pathname.match(/^\/(ru|en|es|he)\//)?.[1] || 'ru');
            const langPath = langPrefix && langPrefix !== 'ru' ? `/${langPrefix}` : '';
            
            const newUrl = `${langPath}/trading/${currentSymbol}/?market_type=${marketType}`;
            window.location.href = newUrl;
        });
    }
    
    function calculateChartHeight() {
        // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –≥—Ä–∞—Ñ–∏–∫–∞ —á–µ—Ä–µ–∑ getBoundingClientRect
        const chartContainer = document.querySelector('.trading-chart-container');
        if (chartContainer) {
            const rect = chartContainer.getBoundingClientRect();
            if (rect.height > 100) {
                return rect.height;
            }
        }
        
        // Fallback: —Ä–∞—Å—á–µ—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ–∫–Ω–∞ —Å —É—á–µ—Ç–æ–º –Ω–∞–≤–±–∞—Ä–∞
        const windowHeight = window.innerHeight;
        const navbar = document.querySelector('.navbar');
        const navbarHeight = navbar ? navbar.getBoundingClientRect().height : 60;
        const header = document.querySelector('.trading-header');
        const headerHeight = header ? header.getBoundingClientRect().height : 100;
        
        const calculatedHeight = windowHeight - navbarHeight - headerHeight;
        
        // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≤—ã—Å–æ—Ç—É –≤ 5 —Ä–∞–∑ (–∫–∞–∫ –ø—Ä–æ—Å–∏–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å)
        const finalHeight = calculatedHeight * 5;
        
        // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –¥–ª—è –º–∞–ª–µ–Ω—å–∫–∏—Ö —ç–∫—Ä–∞–Ω–æ–≤ (—Ç–∞–∫–∂–µ —É–≤–µ–ª–∏—á–µ–Ω–Ω–∞—è)
        return Math.max(2500, finalHeight);
    }
    
    function initTradingView() {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –≤–∏–¥–∏–º
        const container = document.getElementById('tradingview-widget-container');
        const widgetDiv = document.getElementById('tradingview-widget');
        
        if (!container || !widgetDiv) {
            console.error('TradingView container not found!');
            return;
        }
        
        // –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –≤–∏–¥–∏–º
        container.style.display = 'block';
        container.style.visibility = 'visible';
        container.style.opacity = '1';
        widgetDiv.style.display = 'block';
        widgetDiv.style.visibility = 'visible';
        widgetDiv.style.opacity = '1';
        
        // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Ä–∞—Å—á–µ—Ç–∞ –≤—ã—Å–æ—Ç—ã –ø–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è flexbox
        setTimeout(function() {
            const chartHeight = calculateChartHeight();
            console.log('Chart height calculated:', chartHeight);
            
            if (container) {
                container.style.height = chartHeight + 'px';
                container.style.minHeight = chartHeight + 'px';
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ TradingView –∑–∞–≥—Ä—É–∂–µ–Ω
            if (typeof TradingView === 'undefined') {
                console.error('TradingView library not loaded!');
                return;
            }
            
            const widgetConfig = {
                "autosize": true,
                "symbol": `BINANCE:${currentSymbol}`,
                "interval": "1",
                "timezone": "Etc/UTC",
                "theme": "dark",
                "style": "1",
                "locale": "{{ LANGUAGE_CODE }}",
                "toolbar_bg": "#000000",
                "enable_publishing": false,
                "hide_top_toolbar": false,
                "hide_legend": false,
                "save_image": false,
                "container_id": "tradingview-widget",
                "height": chartHeight,
                "width": "100%"
            };
            
            try {
                new TradingView.widget(widgetConfig);
                console.log('TradingView widget initialized');
            } catch (error) {
                console.error('Error initializing TradingView widget:', error);
            }
        }, 500);
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—ã—Å–æ—Ç—ã –≥—Ä–∞—Ñ–∏–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
    let resizeTimeout;
    
    function updateChartHeight() {
        // –ü—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ flexbox –≤—ã—Å–æ—Ç–∞ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
        // –ù–æ –º–æ–∂–Ω–æ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        const container = document.getElementById('tradingview-widget-container');
        if (container && tradingViewWidget) {
            const chartHeight = calculateChartHeight();
            // TradingView –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∞–¥–∞–ø—Ç–∏—Ä—É–µ—Ç—Å—è –∫ —Ä–∞–∑–º–µ—Ä—É –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        }
    }
    
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(updateChartHeight, 250);
    });
    
    initTradingView();
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∏–¥–∂–µ—Ç –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
    setTimeout(function() {
        tradingViewWidget = document.getElementById('tradingview-widget');
    }, 1000);
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–µ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    const STATS_CONFIG_KEY = 'trading_terminal_stats_config';
    
    // –î–æ—Å—Ç—É–ø–Ω—ã–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏ —Å –∏—Ö —Ç–∞–π–º—Ñ—Ä–µ–π–º–∞–º–∏
    // –õ–µ–π–±–ª—ã –±—É–¥—É—Ç –ø–µ—Ä–µ–≤–µ–¥–µ–Ω—ã —á–µ—Ä–µ–∑ gettext –≤ Python, –∑–¥–µ—Å—å –æ—Å—Ç–∞–≤–ª—è–µ–º –∞–Ω–≥–ª–∏–π—Å–∫–∏–µ –¥–ª—è –∫–ª—é—á–µ–π
    const AVAILABLE_METRICS = {
        'volume': { label: '{% trans "Vol" %}', timeframes: ['5m', '15m', '1h', '8h', '1d'], format: 'volume' },
        'oi_change': { label: '{% trans "OI Œî" %}', timeframes: ['5m', '15m', '1h', '8h', '1d'], format: 'percentage' },
        'change': { label: '{% trans "Change" %}', timeframes: ['5m', '15m', '1h', '8h', '1d'], format: 'percentage' },
        'vdelta': { label: '{% trans "Vdelta" %}', timeframes: ['5m', '15m', '1h', '8h', '1d'], format: 'vdelta' },
        'volatility': { label: '{% trans "Vol" %}', timeframes: ['5m', '15m', '1h'], format: 'volatility' },
        'ticks': { label: '{% trans "Ticks" %}', timeframes: ['5m', '15m', '1h'], format: 'integer' },
        'funding_rate': { label: '{% trans "Funding" %}', timeframes: [], format: 'funding' },
        'open_interest': { label: '{% trans "OI" %}', timeframes: [], format: 'volume' },
    };
    
    // –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏–∑ localStorage –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    function loadStatsConfig() {
        const saved = localStorage.getItem(STATS_CONFIG_KEY);
        if (saved) {
            try {
                return JSON.parse(saved);
            } catch (e) {
                console.error('Failed to parse stats config:', e);
            }
        }
        // –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        return [
            { metric: 'volume', timeframe: '15m' },
            { metric: 'oi_change', timeframe: '15m' },
            { metric: 'funding_rate', timeframe: null },
            { metric: 'open_interest', timeframe: null },
        ];
    }
    
    // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –≤ localStorage
    function saveStatsConfig(config) {
        localStorage.setItem(STATS_CONFIG_KEY, JSON.stringify(config));
    }
    
    // –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π
    function formatStatValue(value, formatType) {
        if (value === null || value === undefined || isNaN(value)) return '0.00';
        const num = Number(value);
        
        switch (formatType) {
            case 'volume':
                const absV = Math.abs(num);
                if (absV >= 1_000_000_000) return (num / 1_000_000_000).toFixed(2) + 'B';
                if (absV >= 1_000_000) return (num / 1_000_000).toFixed(2) + 'M';
                if (absV >= 1_000) return (num / 1_000).toFixed(2) + 'K';
                return num.toFixed(2);
            case 'percentage':
                return num.toFixed(2) + '%';
            case 'funding':
                return num.toFixed(4);
            case 'vdelta':
                const absVd = Math.abs(num);
                if (absVd >= 1_000_000) return (num / 1_000_000).toFixed(2) + 'M';
                if (absVd >= 1_000) return (num / 1_000).toFixed(2) + 'K';
                if (absVd >= 1) {
                    if (absVd === Math.floor(absVd)) return String(Math.round(num));
                    return num.toFixed(1);
                }
                return num.toFixed(2);
            case 'volatility':
                const absVol = Math.abs(num);
                if (absVol >= 1) return num.toFixed(2);
                return num.toFixed(3);
            case 'integer':
                return String(Math.round(num));
            default:
                return num.toFixed(2);
        }
    }
    
    // –ü–æ–ª—É—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ snapshot
    function getStatValue(snapshot, metric, timeframe) {
        if (!snapshot) return null;
        
        const fieldName = timeframe ? `${metric}_${timeframe}` : metric;
        return snapshot[fieldName] !== undefined ? snapshot[fieldName] : null;
    }
    
    // –•—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
    let previousStatsValues = {};
    
    // –§—É–Ω–∫—Ü–∏—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π (—Ç–∞ –∂–µ –ª–æ–≥–∏–∫–∞, —á—Ç–æ –∏ –≤ —Å–∫—Ä–∏–Ω–µ—Ä–µ)
    function getComparisonClass(currentValue, previousValue, isPositiveOnly = false) {
        const current = Number(currentValue);
        const previous = previousValue !== null && previousValue !== undefined && previousValue !== "" ? Number(previousValue) : null;
        
        if (isNaN(current)) return "";
        
        if (previous !== null && !isNaN(previous)) {
            const diff = current - previous;
            if (diff > 0.0001) return "value-up";
            if (diff < -0.0001) return "value-down";
            return "";
        }
        
        return "";
    }
    
    // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –º–µ—Ç—Ä–∏–∫–∞ "positive-only" (–≤—Å–µ–≥–¥–∞ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–∞—è)
    function isPositiveOnlyMetric(metric) {
        return ['volume', 'open_interest', 'volatility', 'ticks'].includes(metric);
    }
    
    // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å —Ü–≤–µ—Ç–æ–≤–æ–π –ª–æ–≥–∏–∫–æ–π –∫–∞–∫ –≤ —Å–∫—Ä–∏–Ω–µ—Ä–µ
    function renderStats(snapshot) {
        const container = document.getElementById('trading-stats-container');
        if (!container) return;
        
        const config = loadStatsConfig();
        container.innerHTML = '';
        
        config.forEach(item => {
            const metricInfo = AVAILABLE_METRICS[item.metric];
            if (!metricInfo) return;
            
            const value = getStatValue(snapshot, item.metric, item.timeframe);
            const formatted = formatStatValue(value, metricInfo.format);
            
            const statItem = document.createElement('div');
            statItem.className = 'stat-item-inline';
            
            const label = document.createElement('span');
            label.className = 'stat-label';
            label.textContent = item.timeframe ? `${metricInfo.label} ${item.timeframe}:` : `${metricInfo.label}:`;
            
            const valueSpan = document.createElement('span');
            valueSpan.className = 'stat-value';
            
            // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ü–≤–µ—Ç–æ–≤–æ–π –ª–æ–≥–∏–∫–∏ –∫–∞–∫ –≤ —Å–∫—Ä–∏–Ω–µ—Ä–µ (—Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å –ø—Ä–µ–¥—ã–¥—É—â–∏–º –∑–Ω–∞—á–µ–Ω–∏–µ–º)
            const statKey = item.timeframe ? `${item.metric}_${item.timeframe}` : item.metric;
            const previousValue = previousStatsValues[statKey];
            const isPositiveOnly = isPositiveOnlyMetric(item.metric);
            const colorClass = getComparisonClass(value, previousValue, isPositiveOnly);
            
            if (colorClass) {
                valueSpan.classList.add(colorClass);
            }
            
            valueSpan.textContent = formatted;
            
            statItem.appendChild(label);
            statItem.appendChild(valueSpan);
            container.appendChild(statItem);
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–∞–∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–µ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            if (value !== null && !isNaN(Number(value))) {
                previousStatsValues[statKey] = Number(value);
            }
        });
    }
    
    // –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    function showStatsConfigModal() {
        const config = loadStatsConfig();
        const modal = document.createElement('div');
        modal.className = 'stats-config-modal';
        modal.innerHTML = `
            <div class="stats-config-content">
                <div class="stats-config-header">
                    <h2>{% trans "Configure indicators" %}</h2>
                    <button class="close-modal-btn" onclick="this.closest('.stats-config-modal').remove()">√ó</button>
                </div>
                <div class="stats-config-body" id="stats-config-body">
                    <!-- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∞ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
                </div>
                <div class="stats-config-footer">
                    <button class="btn-secondary" onclick="this.closest('.stats-config-modal').remove()">{% trans "Cancel" %}</button>
                    <button class="btn-primary" id="save-stats-config">{% trans "Save" %}</button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        const body = document.getElementById('stats-config-body');
        let configIndex = 0;
        
        // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        config.forEach((item, idx) => {
            addStatConfigRow(body, item, idx);
            configIndex = idx + 1;
        });
        
        // –ö–Ω–æ–ø–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–∫–∞–∑–∞—Ç–µ–ª—è
        const addBtn = document.createElement('button');
        addBtn.className = 'btn-secondary btn-small';
        addBtn.textContent = '+ {% trans "Add indicator" %}';
        addBtn.onclick = () => addStatConfigRow(body, null, configIndex++);
        body.appendChild(addBtn);
        
        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        document.getElementById('save-stats-config').onclick = () => {
            const rows = body.querySelectorAll('.stat-config-row');
            const newConfig = [];
            rows.forEach(row => {
                const metricSelect = row.querySelector('.metric-select');
                const timeframeSelect = row.querySelector('.timeframe-select');
                const removeBtn = row.querySelector('.remove-stat-btn');
                
                if (removeBtn && removeBtn.dataset.removed === 'true') return;
                
                if (metricSelect && metricSelect.value) {
                    newConfig.push({
                        metric: metricSelect.value,
                        timeframe: timeframeSelect ? timeframeSelect.value || null : null
                    });
                }
            });
            
            saveStatsConfig(newConfig);
            renderStats(window.currentSnapshot || null);
            modal.remove();
        };
    }
    
    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    function addStatConfigRow(container, item, index) {
        const row = document.createElement('div');
        row.className = 'stat-config-row';
        
        const metricSelect = document.createElement('select');
        metricSelect.className = 'metric-select';
        metricSelect.innerHTML = '<option value="">{% trans "Select indicator" %}</option>';
        Object.keys(AVAILABLE_METRICS).forEach(key => {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = AVAILABLE_METRICS[key].label;
            if (item && item.metric === key) option.selected = true;
            metricSelect.appendChild(option);
        });
        
        const timeframeSelect = document.createElement('select');
        timeframeSelect.className = 'timeframe-select';
        timeframeSelect.innerHTML = '<option value="">{% trans "No" %}</option>';
        
        function updateTimeframes() {
            const selectedMetric = metricSelect.value;
            const metricInfo = AVAILABLE_METRICS[selectedMetric];
            timeframeSelect.innerHTML = '<option value="">{% trans "No" %}</option>';
            
            if (metricInfo && metricInfo.timeframes.length > 0) {
                metricInfo.timeframes.forEach(tf => {
                    const option = document.createElement('option');
                    option.value = tf;
                    option.textContent = tf;
                    if (item && item.timeframe === tf) option.selected = true;
                    timeframeSelect.appendChild(option);
                });
            }
            timeframeSelect.style.display = metricInfo && metricInfo.timeframes.length > 0 ? 'block' : 'none';
        }
        
        metricSelect.onchange = updateTimeframes;
        updateTimeframes();
        
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-stat-btn btn-small';
        removeBtn.textContent = '√ó';
        removeBtn.onclick = () => {
            row.style.display = 'none';
            removeBtn.dataset.removed = 'true';
        };
        
        row.appendChild(metricSelect);
        row.appendChild(timeframeSelect);
        row.appendChild(removeBtn);
        container.insertBefore(row, container.lastChild);
    }
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    document.getElementById('configure-stats-btn')?.addEventListener('click', showStatsConfigModal);
    
    // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç currentSymbol)
    function updateStats() {
        // Build API path based on current URL structure (same logic as screener.js)
        const currentPath = window.location.pathname;
        const pathParts = currentPath.split('/').filter(p => p);
        const hasLangPrefix = pathParts.length > 0 && ['ru', 'en', 'es', 'he'].includes(pathParts[0]);
        
        // Build API path: if current URL has language prefix, use it; otherwise use /api/ directly
        const apiPath = hasLangPrefix 
            ? `/${pathParts[0]}/api/symbol/`
            : `/api/symbol/`;
        
        fetch(`${apiPath}${encodeURIComponent(currentSymbol)}/?market_type=${marketType}`)
            .then(res => res.json())
            .then(data => {
                if (data.latest) {
                    window.currentSnapshot = data.latest;
                    
                    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–Ω—ã
                    const priceEl = document.getElementById('current-price');
                    if (priceEl) {
                        priceEl.textContent = parseFloat(data.latest.price).toFixed(8);
                    }
                    const change = parseFloat(data.latest.change_15m || 0);
                    const changeEl = document.getElementById('price-change');
                    if (changeEl) {
                        changeEl.textContent = change.toFixed(2) + '%';
                        changeEl.className = 'price-change ' + (change > 0 ? 'positive' : change < 0 ? 'negative' : '');
                    }
                    
                    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
                    renderStats(data.latest);
                }
            })
            .catch(err => console.error('Failed to update stats:', err));
    }
    
    // –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ - parse JSON data from script tag
    // Parse JSON data if it exists
    let initialSnapshot = null;
    {% if snapshot_data %}
    const initialSnapshotScript = document.getElementById('initial-snapshot-data');
    if (initialSnapshotScript) {
        try {
            initialSnapshot = JSON.parse(initialSnapshotScript.textContent);
        } catch (e) {
            console.error('Failed to parse initial snapshot:', e);
            initialSnapshot = null;
        }
    }
    {% endif %}
    
    window.currentSnapshot = initialSnapshot;
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è previousStatsValues –ø—Ä–∏ –ø–µ—Ä–≤–æ–π –∑–∞–≥—Ä—É–∑–∫–µ
    if (initialSnapshot) {
        const config = loadStatsConfig();
        config.forEach(item => {
            const statKey = item.timeframe ? `${item.metric}_${item.timeframe}` : item.metric;
            const value = getStatValue(initialSnapshot, item.metric, item.timeframe);
            if (value !== null && !isNaN(Number(value))) {
                previousStatsValues[statKey] = Number(value);
            }
        });
    }
    
    // Render stats with initial snapshot
    renderStats(initialSnapshot);
    
    // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    setInterval(updateStats, 5000);
});
</script>
{% endblock %}

